#target servers
$servers = @("HLMM") #servername or names

#Target database 
$databasename = 'admin'
#duration and interval
$durationseconds = 30
$intervalseconds = 1
$maxsamples = [int][math]::ceiling($durationseconds / $intervalseconds)

#output directory on this compuiter

$savepath = "C:\PerfmonResults"
if(!(test-path $savepath)) { New-Item -ItemType directory -Path $savepath -Force | out-null }

function  Get-SqlCounterObjects {
    param([string]$computerName)
    
    try {
    $sets = Get-Counter -ComputerName $computerName -ListSet '*availability*', '*replica*', '*database*', '*databases*' -ErrorAction Stop
    return $sets
    } catch { Write-Warning "[$computername] unable to query counters sets. check remote registry, firewall, and permissions. $_"
    return @()
    }
    }

function select-objectname {
param([string[]]$availablitynames, [string]$family #e.g. 'availability replica', 'database replica', 'databases'..
)
#prefer name-instance (MSSQL$X:) object names first; otherwise sql server
$availablitynames | 
Where-Object { $_ -like "*:$family" } | 
Sort-Object { if ($_ -like 'mssql$*' ) { 0 } else { 1 } } |
Select-object -First 1
}


function try-getinstances {
Param(
[object]$counterset, # object from get-counter -listset
[string]$likefiltertext # e.g., 'databasename' to try to narrow instances
)
if (-not $counterset) { return @() }

$inst = @()
try {
$inst = $counterset.instances
} catch { 
$inst = @()
}

if (-not $inst) { return @() }

  
  # try to pick instances that contain the db name (case-insensittive)
  $Match = $inst | Where-Object { $_ -match [regex]::escape($likefiltertext) }
  if ($Match -and $Match.Count -gt 0) { return $Match }
  
  # no direct match; return empty so caller can decide to fallback to (*) 
  return @()
  }
  
  function resolve-countersforserver {
  param(
  [string]$computername, [string]$DBname
  )
  $sets = Get-SqlCounterObjects -computerName $computername
  if (-not $sets -or $sets.count -eq 0) {
      return @()
  }

  $availablenames = $sets | Select-Object -ExcludeProperty countersetname
# Resolve object names (default vs named instance)
$objAvailabilityReplica = Select-ObjectName -AvailableNames $availableNames -Family 'Availability Replica'
$objDatabaseReplica     = Select-ObjectName -AvailableNames $availableNames -Family 'Database Replica'
$objDatabases           = Select-ObjectName -AvailableNames $availableNames -Family 'Databases'

if (-not $objDatabases) {
    Write-Warning "[$computerName] Could not resolve 'Databases' counter object."
}
if (-not $objDatabaseReplica) {
    Write-Warning "[$computerName] Could not resolve 'Database Replica' counter object."
}
if (-not $objAvailabilityReplica) {
    Write-Warning "[$computerName] Could not resolve 'Availability Replica' counter object."
}

$resolved = New-Object System.Collections.Generic.List[string]

# 1) DB-scoped counters for 'core'
if ($objDatabaseReplica) {
    foreach ($cn in @('Log Bytes Sent/sec','Log Bytes Received/sec')) {
        $path = "\$objDatabaseReplica($DBname)\$cn"
        try {
            $null = Get-Counter -ComputerName $computerName -Counter $path -MaxSamples 1 -ErrorAction Stop
            $resolved.Add($path) | Out-Null
        } catch {
            Write-Warning "[$computerName] Counter not found: $path"
        }
    }
}

if ($objDatabases) {
    $path = "\$objDatabases($DBname)\Log Bytes Flushed/sec"
    try {
        $null = Get-Counter -ComputerName $computerName -Counter $path -MaxSamples 1 -ErrorAction Stop
        $resolved.Add($path) | Out-Null
    } catch {
        Write-Warning "[$computerName] Counter not found: $path"
    }
}

# 2) Replica-level counters (attempt to filter instances to those containing 'core')
if ($objAvailabilityReplica) {
    $setAvail = $sets | Where-Object { $_.CounterSetName -eq $objAvailabilityReplica }

    # Try to get instances that include the DB name; if none, fallback to (*)
    $instCandidates = Try-GetInstances -CounterSet $setAvail -LikeFilterText $DBname
    $instList = @()
    if ($instCandidates -and $instCandidates.Count -gt 0) {
        $instList = $instCandidates
    } else {
        # Fallback: keep (*) so you still capture
        $instList = @('*')
    }

    $replicaCounters = @(
        'Bytes Received from Replica/sec'
        'Bytes Sent to Replica/sec'
        'Flow Control/sec'
    )

    foreach ($inst in $instList) {
        # If instance is (*) leave as wildcard; otherwise use the instance name
        $instText = if ($inst -eq '*') { '*' } else { "($inst)" }
        foreach ($cn in $replicaCounters) {
            $path = "\$objAvailabilityReplica$instText\$cn"
            try {
                $null = Get-Counter -ComputerName $computerName -Counter $path -MaxSamples 1 -ErrorAction Stop
                $resolved.Add($path) | Out-Null
            } catch {
                Write-Warning "[$computerName] Counter not found: $path"
            }
        }
    }
}

# Deduplicate and return
$resolved | Select-Object -Unique
}

foreach ($server in $servers) {
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $safeServer = ($server -replace '[\\\/:\*\?\"\<\>\|]', '_')
    $outFile = Join-Path $savePath "PerfData_${safeServer}_${databaseName}_$timestamp.blg"

    Write-Host "Resolving counters on $server for DB '$databaseName' ..."
    $counters = Resolve-CountersForServer -ComputerName $server -DBName $databaseName

    if (-not $counters -or $counters.Count -eq 0) {
        Write-Warning "[$server] No valid counters resolved. Nothing to collect."
        continue
    }

    Write-Host "Collecting counters for '$databaseName' from $server for $durationSeconds seconds (interval $intervalSeconds)"
    try {
        $samples = Get-Counter -ComputerName $server -Counter $counters `
                    -SampleInterval $intervalSeconds -MaxSamples $maxSamples -ErrorAction Stop
        $samples | Export-Counter -Path $outFile -FileFormat BLG -Force

        Write-Host "Saved PerfMon BLG to $outFile"
        Write-Host "Counters collected:"
        $counters | ForEach-Object { Write-Host "  $_" }
    } catch {
        Write-Error "[$server] Collection failed: $_"
    }
}


             
